import numpy as _np
import numpy.typing as npt
import typing
from basix._basixcpp import CellType, DPCVariant, ElementFamily, FiniteElement_float32 as _FiniteElement_float32, FiniteElement_float64 as _FiniteElement_float64, LagrangeVariant, MapType, PolysetType, SobolevSpace

__all__ = ['FiniteElement', 'create_element', 'create_custom_element', 'string_to_family']

class FiniteElement:
    def __init__(self, e: typing.Union[_FiniteElement_float32, _FiniteElement_float64]) -> None: ...
    def tabulate(self, n: int, x: npt.NDArray) -> npt.NDArray[_np.float_]: ...
    def __eq__(self, other) -> bool: ...
    def push_forward(self, U, J, detJ, K) -> npt.NDArray[_np.float_]: ...
    def pull_back(self, u: npt.NDArray, J: npt.NDArray, detJ: npt.NDArray, K: npt.NDArray) -> npt.NDArray[_np.float_]: ...
    def pre_apply_dof_transformation(self, data, block_size, cell_info) -> None: ...
    def post_apply_transpose_dof_transformation(self, data, block_size, cell_info) -> None: ...
    def pre_apply_inverse_transpose_dof_transformation(self, data, block_size, cell_info) -> None: ...
    def base_transformations(self) -> npt.NDArray[_np.float_]: ...
    def entity_transformations(self) -> dict: ...
    def get_tensor_product_representation(self) -> typing.List[typing.Tuple[typing.List[typing.Union[_FiniteElement_float32, _FiniteElement_float64]], typing.List[int]]]: ...
    @property
    def degree(self) -> int: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def cell_type(self) -> CellType: ...
    @property
    def polyset_type(self) -> PolysetType: ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> typing.List[typing.List[int]]: ...
    @property
    def entity_dofs(self) -> typing.List[typing.List[typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> typing.List[typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> typing.List[typing.List[typing.List[int]]]: ...
    @property
    def value_size(self) -> int: ...
    @property
    def value_shape(self) -> typing.List[int]: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def family(self) -> ElementFamily: ...
    @property
    def lagrange_variant(self) -> LagrangeVariant: ...
    @property
    def dpc_variant(self) -> DPCVariant: ...
    @property
    def dof_transformations_are_permutations(self) -> bool: ...
    @property
    def dof_transformations_are_identity(self) -> bool: ...
    @property
    def interpolation_is_identity(self) -> bool: ...
    @property
    def map_type(self) -> MapType: ...
    @property
    def sobolev_space(self) -> SobolevSpace: ...
    @property
    def points(self): ...
    @property
    def interpolation_matrix(self): ...
    @property
    def dual_matrix(self): ...
    @property
    def coefficient_matrix(self): ...
    @property
    def wcoeffs(self): ...
    @property
    def M(self): ...
    @property
    def x(self): ...
    @property
    def has_tensor_product_factorisation(self) -> bool: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def dof_ordering(self) -> typing.List[int]: ...

def create_element(family_name: ElementFamily, cell_name: CellType, degree: int, lvariant: LagrangeVariant = ..., dpc_variant: DPCVariant = ..., discontinuous: bool = False, dof_ordering: typing.List[int] = [], dtype: npt.DTypeLike = ...) -> FiniteElement: ...
def create_custom_element(cell_name: CellType, value_shape, wcoeffs, x, M, interpolation_nderivs: int, map_type, sobolev_space, discontinuous: bool, embedded_subdegree: int, embedded_superdegree: int, poly_type: PolysetType) -> FiniteElement: ...
def string_to_family(family: str, cell: str) -> ElementFamily: ...
