import abc
import basix as _basix
import numpy as _np
import numpy.typing as _npt
import typing as _typing
import ufl as _ufl
from abc import abstractmethod as _abstractmethod
from ufl.finiteelement import AbstractFiniteElement as _AbstractFiniteElement
from ufl.pullback import AbstractPullback as _AbstractPullback

__all__ = ['element', 'enriched_element', 'custom_element', 'mixed_element', 'quadrature_element', 'real_element', 'blocked_element']

class _ElementBase(_AbstractFiniteElement, metaclass=abc.ABCMeta):
    def __init__(self, repr: str, cellname: str, value_shape: _typing.Tuple[int, ...], degree: int = -1, pullback: _AbstractPullback = ..., gdim: _typing.Optional[int] = None) -> None: ...
    def __hash__(self) -> int: ...
    @_abstractmethod
    def __eq__(self, other) -> bool: ...
    @property
    def sobolev_space(self): ...
    @property
    def pullback(self) -> _AbstractPullback: ...
    @property
    @abc.abstractmethod
    def embedded_superdegree(self) -> int: ...
    @property
    @abc.abstractmethod
    def embedded_subdegree(self) -> int: ...
    @property
    def cell(self) -> _ufl.Cell: ...
    @property
    def reference_value_shape(self) -> _typing.Tuple[int, ...]: ...
    @property
    def sub_elements(self) -> _typing.List[_AbstractFiniteElement]: ...
    @_abstractmethod
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    @_abstractmethod
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_typing.Any, int, int]: ...
    @property
    @abc.abstractmethod
    def ufcx_element_type(self) -> str: ...
    @property
    @abc.abstractmethod
    def dim(self) -> int: ...
    @property
    @abc.abstractmethod
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    @abc.abstractmethod
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    @abc.abstractmethod
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    @abc.abstractmethod
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    @abc.abstractmethod
    def num_global_support_dofs(self) -> int: ...
    @property
    @abc.abstractmethod
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    @abc.abstractmethod
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    @abc.abstractmethod
    def family_name(self) -> str: ...
    @property
    @abc.abstractmethod
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    @abc.abstractmethod
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    @abc.abstractmethod
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    @abc.abstractmethod
    def cell_type(self) -> _basix.CellType: ...
    @property
    @abc.abstractmethod
    def discontinuous(self) -> bool: ...
    @property
    @abc.abstractmethod
    def map_type(self) -> _basix.MapType: ...
    @property
    @abc.abstractmethod
    def polyset_type(self) -> _basix.PolysetType: ...
    @property
    @abc.abstractmethod
    def basix_sobolev_space(self): ...
    def get_tensor_product_representation(self) -> None: ...
    @property
    def degree(self) -> int: ...
    def custom_quadrature(self) -> _typing.Tuple[_npt.NDArray[_np.float64], _npt.NDArray[_np.float64]]: ...
    @property
    def has_tensor_product_factorisation(self) -> bool: ...
    @property
    def block_size(self) -> int: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def is_custom_element(self) -> bool: ...
    @property
    def has_custom_quadrature(self) -> bool: ...
    @property
    def basix_element(self) -> None: ...

class _BasixElement(_ElementBase):
    def __init__(self, element: _basix.finite_element.FiniteElement, gdim: _typing.Optional[int] = None) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    def get_tensor_product_representation(self): ...
    @property
    def basix_sobolev_space(self): ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def family_name(self) -> str: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def is_custom_element(self) -> bool: ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...
    @property
    def has_tensor_product_factorisation(self) -> bool: ...
    @property
    def basix_element(self): ...

class _ComponentElement(_ElementBase):
    def __init__(self, element: _ElementBase, component: int, gdim: _typing.Optional[int] = None) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __mul__(self, other): ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    @property
    def basix_sobolev_space(self): ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def family_name(self) -> str: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def basix_element(self): ...

class _MixedElement(_ElementBase):
    def __init__(self, sub_elements: _typing.List[_ElementBase], gdim: _typing.Optional[int] = None) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def degree(self) -> int: ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def basix_sobolev_space(self): ...
    @property
    def sub_elements(self) -> _typing.List[_ElementBase]: ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def family_name(self) -> str: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...
    def custom_quadrature(self) -> _typing.Tuple[_npt.NDArray[_np.float64], _npt.NDArray[_np.float64]]: ...
    @property
    def has_custom_quadrature(self) -> bool: ...

class _BlockedElement(_ElementBase):
    def __init__(self, sub_element: _ElementBase, shape: _typing.Tuple[int, ...], symmetry: _typing.Optional[bool] = None, gdim: _typing.Optional[int] = None) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    def get_tensor_product_representation(self): ...
    @property
    def block_size(self) -> int: ...
    @property
    def reference_value_shape(self) -> _typing.Tuple[int, ...]: ...
    @property
    def basix_sobolev_space(self): ...
    @property
    def sub_elements(self) -> _typing.List[_ElementBase]: ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def family_name(self) -> str: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def interpolation_nderivs(self) -> int: ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...
    @property
    def has_tensor_product_factorisation(self) -> bool: ...
    def custom_quadrature(self) -> _typing.Tuple[_npt.NDArray[_np.float64], _npt.NDArray[_np.float64]]: ...
    @property
    def has_custom_quadrature(self) -> bool: ...
    @property
    def basix_element(self): ...

class _QuadratureElement(_ElementBase):
    def __init__(self, cell: _basix.CellType, points: _npt.NDArray[_np.float64], weights: _npt.NDArray[_np.float64], pullback: _AbstractPullback, degree: _typing.Optional[int] = None) -> None: ...
    def basix_sobolev_space(self): ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    def custom_quadrature(self) -> _typing.Tuple[_npt.NDArray[_np.float64], _npt.NDArray[_np.float64]]: ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def dim(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def family_name(self) -> str: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...
    @property
    def has_custom_quadrature(self) -> bool: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...

class _RealElement(_ElementBase):
    def __init__(self, cell: _basix.CellType, value_shape: _typing.Tuple[int, ...]) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def tabulate(self, nderivs: int, points: _npt.NDArray[_np.float64]) -> _npt.NDArray[_np.float64]: ...
    def get_component_element(self, flat_component: int) -> _typing.Tuple[_ElementBase, int, int]: ...
    @property
    def ufcx_element_type(self) -> str: ...
    @property
    def dim(self) -> int: ...
    @property
    def embedded_superdegree(self) -> int: ...
    @property
    def embedded_subdegree(self) -> int: ...
    @property
    def num_entity_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_entity_closure_dofs(self) -> _typing.List[_typing.List[int]]: ...
    @property
    def entity_closure_dofs(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def num_global_support_dofs(self) -> int: ...
    @property
    def reference_topology(self) -> _typing.List[_typing.List[_typing.List[int]]]: ...
    @property
    def reference_geometry(self) -> _npt.NDArray[_np.float64]: ...
    @property
    def family_name(self) -> str: ...
    @property
    def lagrange_variant(self) -> _typing.Union[_basix.LagrangeVariant, None]: ...
    @property
    def dpc_variant(self) -> _typing.Union[_basix.DPCVariant, None]: ...
    @property
    def element_family(self) -> _typing.Union[_basix.ElementFamily, None]: ...
    @property
    def cell_type(self) -> _basix.CellType: ...
    @property
    def discontinuous(self) -> bool: ...
    @property
    def basix_sobolev_space(self): ...
    @property
    def map_type(self) -> _basix.MapType: ...
    @property
    def polyset_type(self) -> _basix.PolysetType: ...

def element(family: _typing.Union[_basix.ElementFamily, str], cell: _typing.Union[_basix.CellType, str], degree: int, lagrange_variant: _basix.LagrangeVariant = ..., dpc_variant: _basix.DPCVariant = ..., discontinuous: bool = False, shape: _typing.Optional[_typing.Tuple[int, ...]] = None, symmetry: _typing.Optional[bool] = None, gdim: _typing.Optional[int] = None) -> _ElementBase: ...
def enriched_element(elements: _typing.List[_ElementBase], map_type: _typing.Optional[_basix.MapType] = None, gdim: _typing.Optional[int] = None) -> _ElementBase: ...
def custom_element(cell_type: _basix.CellType, value_shape: _typing.Union[_typing.List[int], _typing.Tuple[int, ...]], wcoeffs: _npt.NDArray[_np.float64], x: _typing.List[_typing.List[_npt.NDArray[_np.float64]]], M: _typing.List[_typing.List[_npt.NDArray[_np.float64]]], interpolation_nderivs: int, map_type: _basix.MapType, sobolev_space: _basix.SobolevSpace, discontinuous: bool, embedded_subdegree: int, embedded_superdegree: int, polyset_type: _basix.PolysetType = ..., gdim: _typing.Optional[int] = None) -> _ElementBase: ...
def mixed_element(elements: _typing.List[_ElementBase], gdim: _typing.Optional[int] = None) -> _ElementBase: ...
def quadrature_element(cell: _typing.Union[str, _basix.CellType], value_shape: _typing.Tuple[int, ...] = (), scheme: _typing.Optional[str] = None, degree: _typing.Optional[int] = None, points: _typing.Optional[_npt.NDArray[_np.float64]] = None, weights: _typing.Optional[_npt.NDArray[_np.float64]] = None, pullback: _AbstractPullback = ...) -> _ElementBase: ...
def real_element(cell: _typing.Union[_basix.CellType, str], value_shape: _typing.Tuple[int, ...]) -> _ElementBase: ...
def blocked_element(sub_element: _ElementBase, shape: _typing.Tuple[int, ...], symmetry: _typing.Optional[bool] = None, gdim: _typing.Optional[int] = None) -> _ElementBase: ...
